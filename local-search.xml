<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Jsp+Servlet笔记</title>
    <link href="/lizheng/2021/08/20/JSP+Servlet/"/>
    <url>/lizheng/2021/08/20/JSP+Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="JSP-Servlet"><a href="#JSP-Servlet" class="headerlink" title="JSP+Servlet"></a>JSP+Servlet</h1><h2 id="1-web相关概念"><a href="#1-web相关概念" class="headerlink" title="1.web相关概念"></a>1.web相关概念</h2><h3 id="1-1软件架构"><a href="#1-1软件架构" class="headerlink" title="1.1软件架构"></a>1.1软件架构</h3><p>1.B/S：浏览器/服务器端</p><p>2.C/S：客户端/服务器端</p><h3 id="1-2资源分类"><a href="#1-2资源分类" class="headerlink" title="1.2资源分类"></a>1.2资源分类</h3><p>1.静态资源：所有用户浏览结果都一样的，称为静态资源，浏览器可直接解析</p><p>​        HTML ,CSS,JS</p><p>2.动态资源：每个用户访问相同资源，所得的结果可能不同，这样的资源为动态资源，先转换为静态资源，然后返回给浏览器。</p><p>​        servlet/jsp，php</p><h3 id="1-3网络三要素"><a href="#1-3网络三要素" class="headerlink" title="1.3网络三要素"></a>1.3网络三要素</h3><p>1.IP地址 ：电子设备在网络中的唯一标识</p><p>2.端口号 ：应用程序在计算机中的唯一标识。0~65536</p><p>3.传输协议 : 规定了数据传输的规则</p><p>​    UDP：不安全协议，速度快</p><p>​    TCP ：安全的协议，速度慢</p><h2 id="2-服务器"><a href="#2-服务器" class="headerlink" title="2.服务器"></a>2.服务器</h2><p>1.概述 ：安装了服务器软件的计算机</p><p>2.web服务器软件：可以接受用户请求，处理请求并作出响应的软件</p><p>​        部署web项目。 让用户通过浏览器来访问这些项目</p><p>​        动态资源必须依赖于web服务器软件的，所以也被称为web容器</p><p>3.常见的java相关的web服务器软件</p><p>​        webLogic：Oracle公司</p><p>​        webSphere：IBM公司</p><p>​        JBOSS：jboss公司</p><p>​        Tomcat：Apache基金会。中小型javaEE服务器，支持少量javaEE规范，</p><p>​            开源，免费，支持集群，性能优异</p><h2 id="3-TomCat"><a href="#3-TomCat" class="headerlink" title="3.TomCat"></a>3.TomCat</h2><ol><li><p>下载</p></li><li><p>安装</p></li><li><p>卸载</p></li><li><p>启动服务</p><p>​    问题： </p><p>​            闪退：JAVA_HOEM 配置问题</p><p>​            启动报错：查看日志</p></li><li><p>访问</p></li><li><p>关闭</p></li></ol><h2 id="4-Servlet"><a href="#4-Servlet" class="headerlink" title="4.Servlet"></a>4.Servlet</h2><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>​        运行在服务器端的java小程序</p><h4 id="4-2-执行原理"><a href="#4-2-执行原理" class="headerlink" title="4.2 执行原理"></a>4.2 执行原理</h4><ol><li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径<ol start="2"><li>查找web.xml文件，是否有对应的<url-pattern>标签体内容。</li><li>如果有，则在找到对应的<servlet-class>全类名</li><li>tomcat会将字节码文件加载进内存，并且创建其对象</li><li>调用其方法</li></ol></li></ol><h4 id="4-3-Servlet中的生命周期方法："><a href="#4-3-Servlet中的生命周期方法：" class="headerlink" title="4.3 Servlet中的生命周期方法："></a>4.3 Servlet中的生命周期方法：</h4><ol><li><p>被创建：执行init方法，只执行一次</p><pre><code> * Servlet什么时候被创建？     * 默认情况下，第一次被访问时，Servlet被创建     * 可以配置执行Servlet的创建时机。         * 在&lt;servlet&gt;标签下配置             1. 第一次被访问时，创建                 * &lt;load-on-startup&gt;的值为负数             2. 在服务器启动时，创建                 * &lt;load-on-startup&gt;的值为0或正整数</code></pre><ul><li>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的<ul><li><strong>多个用户同时访问时，可能存在线程安全问题。</strong></li><li><strong>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</strong></li></ul></li></ul></li><li><p>提供服务：执行service方法，执行多次</p><pre><code> * 每次访问Servlet时，Service方法都会被调用一次。</code></pre><ol start="3"><li>被销毁：执行destroy方法，只执行一次<ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li><li>只有服务器正常关闭时，才会执行destroy方法。</li><li>destroy方法在Servlet被销毁之前执行，一般用于释放资源</li></ul></li></ol></li></ol><ul><li><p>Servlet3.0：</p><ul><li><p>好处：</p><ul><li>支持注解配置。可以不需要web.xml了。</li></ul></li><li><p>步骤：</p><ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法</li><li>在类上使用@WebServlet注解，进行配置<ul><li>@WebServlet(“资源路径”)</li></ul></li></ol></li></ul></li></ul><h4 id="4-4-Servlet的体系结构"><a href="#4-4-Servlet的体系结构" class="headerlink" title="4.4 Servlet的体系结构"></a>4.4 Servlet的体系结构</h4><p>​    Servlet – 接口<br>​        |<br>​    GenericServlet – 抽象类<br>​        |<br>​    HttpServlet  – 抽象类</p><ul><li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><ul><li>将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</li></ul></li><li><p>HttpServlet：对http协议的一种封装，简化操作</p><ol><li>定义类继承HttpServlet</li><li>复写doGet/doPost方法</li></ol></li></ul><h4 id="4-5-Servlet相关配置"><a href="#4-5-Servlet相关配置" class="headerlink" title="4.5 Servlet相关配置"></a>4.5 Servlet相关配置</h4><ol><li>urlpartten:Servlet访问路径<ol><li>一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”})</li><li>路径定义规则：<ol><li>/xxx：路径匹配</li><li>/xxx/xxx:多层路径，目录结构</li><li>*.do：扩展名匹配</li></ol></li></ol></li></ol><h2 id="6-HTTP"><a href="#6-HTTP" class="headerlink" title="6.HTTP"></a>6.HTTP</h2><ul><li><p>概念：Hyper Text Transfer Protocol 超文本传输协议</p><ul><li><p>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</p></li><li><p>特点：</p><ol><li>基于TCP/IP的高级协议</li><li>默认端口号:80</li><li>基于请求/响应模型的:一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol></li><li><p>历史版本：</p><ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接</li></ul></li></ul></li><li><p>请求消息数据格式</p><ol><li><p>请求行<br>请求方式 请求url 请求协议/版本<br>GET /login.html    HTTP/1.1</p><ul><li>请求方式：<ul><li>HTTP协议有7中请求方式，常用的有2种<ul><li>GET：<ol><li>请求参数在请求行中，在url后。</li><li>请求的url长度有限制的</li><li>不太安全</li></ol></li><li>POST：<ol><li>请求参数在请求体中</li><li>请求的url长度没有限制的</li><li>相对安全</li></ol></li></ul></li></ul></li></ul></li><li><p>请求头：客户端浏览器告诉服务器一些信息<br>请求头名称: 请求头值</p><ul><li><p>常见的请求头：</p><ol><li><p>User-Agent：浏览器告诉服务器     ，我访问你使用的浏览器版本信息</p><ul><li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li></ul></li><li><p>Referer：<a href="http://localhost/login.html">http://localhost/login.html</a></p><ul><li>告诉服务器，我(当前请求)从哪里来？<ul><li>作用：<ol><li>防盗链：</li><li>统计工作：</li></ol></li></ul></li></ul></li></ol></li></ul></li><li><p>请求空行<br>空行，就是用于分割POST请求的请求头，和请求体的。</p></li><li><p>请求体(正文)：</p><ul><li>封装POST请求消息的请求参数的</li></ul></li></ol></li></ul><h2 id="7-Request"><a href="#7-Request" class="headerlink" title="7. Request"></a>7. Request</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> request对象和response对象的原理<br><span class="hljs-number">1.</span> request和response对象是由服务器创建的。我们来使用它们<br><span class="hljs-number">2.</span> request对象是来获取请求消息，response对象是来设置响应消息<br><br><span class="hljs-number">2.</span> request对象继承体系结构：<br>ServletRequest--接口<br>|继承<br>HttpServletRequest-- 接口<br>|实现<br>org.apache.catalina.connector.RequestFacade 类(tomcat)<br><br><span class="hljs-number">3.</span> request功能：<br><span class="hljs-number">1.</span> 获取请求消息数据<br><span class="hljs-number">1.</span> 获取请求行数据<br>* GET /day14/demo1?name=zhangsan HTTP/<span class="hljs-number">1.1</span><br>* 方法：<br><span class="hljs-number">1.</span> 获取请求方式 ：GET<br>* <span class="hljs-function">String <span class="hljs-title">getMethod</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">2. <span class="hljs-params">(*)</span>获取虚拟目录：/day14</span><br><span class="hljs-function">* String <span class="hljs-title">getContextPath</span><span class="hljs-params">()</span></span><br><span class="hljs-function">3. 获取Servlet路径: /demo1</span><br><span class="hljs-function">* String <span class="hljs-title">getServletPath</span><span class="hljs-params">()</span></span><br><span class="hljs-function">4. 获取get方式请求参数：name</span>=zhangsan<br>* <span class="hljs-function">String <span class="hljs-title">getQueryString</span><span class="hljs-params">()</span></span><br><span class="hljs-function">5. <span class="hljs-params">(*)</span>获取请求URI：/day14/demo1</span><br><span class="hljs-function">* String <span class="hljs-title">getRequestURI</span><span class="hljs-params">()</span>:/day14/demo1</span><br><span class="hljs-function">* StringBuffer <span class="hljs-title">getRequestURL</span><span class="hljs-params">()</span>  :http:<span class="hljs-comment">//localhost/day14/demo1</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">* URL:统一资源定位符 ： http:<span class="hljs-comment">//localhost/day14/demo1中华人民共和国</span></span><br><span class="hljs-function">* URI：统一资源标识符 : /day14/demo1共和国</span><br><span class="hljs-function"></span><br><span class="hljs-function">6. 获取协议及版本：HTTP/1.1</span><br><span class="hljs-function">* String <span class="hljs-title">getProtocol</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">7. 获取客户机的IP地址：</span><br><span class="hljs-function">* String <span class="hljs-title">getRemoteAddr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">2. 获取请求头数据</span><br><span class="hljs-function">* 方法：</span><br><span class="hljs-function">* <span class="hljs-params">(*)</span>String <span class="hljs-title">getHeader</span><span class="hljs-params">(String name)</span>:通过请求头的名称获取请求头的值</span><br><span class="hljs-function">* Enumeration&lt;String&gt; <span class="hljs-title">getHeaderNames</span><span class="hljs-params">()</span>:获取所有的请求头名称</span><br><span class="hljs-function"></span><br><span class="hljs-function">3. 获取请求体数据:</span><br><span class="hljs-function">* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</span><br><span class="hljs-function">* 步骤：</span><br><span class="hljs-function">1. 获取流对象</span><br><span class="hljs-function">*  BufferedReader <span class="hljs-title">getReader</span><span class="hljs-params">()</span>：获取字符输入流，只能操作字符数据</span><br><span class="hljs-function">*  ServletInputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span>：获取字节输入流，可以操作所有类型数据</span><br><span class="hljs-function">* 在文件上传知识点后讲解</span><br><span class="hljs-function"></span><br><span class="hljs-function">2. 再从流对象中拿数据</span><br><span class="hljs-function"></span><br><span class="hljs-function">2. 其他功能：</span><br><span class="hljs-function">1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数</span><br><span class="hljs-function"></span><br><span class="hljs-function">1. String <span class="hljs-title">getParameter</span><span class="hljs-params">(String name)</span>:根据参数名称获取参数值   </span><br><span class="hljs-function">                </span><br><span class="hljs-function">2. String[] <span class="hljs-title">getParameterValues</span><span class="hljs-params">(String name)</span>:根据参数名称获取参数值的数组 </span><br><span class="hljs-function"></span><br><span class="hljs-function">3. Enumeration&lt;String&gt; <span class="hljs-title">getParameterNames</span><span class="hljs-params">()</span>:获取所有请求的参数名称</span><br><span class="hljs-function"></span><br><span class="hljs-function">4. Map&lt;String,String[]&gt; <span class="hljs-title">getParameterMap</span><span class="hljs-params">()</span>:获取所有参数的map集合</span><br><span class="hljs-function">                </span><br><span class="hljs-function">                </span><br><span class="hljs-function">                </span><br><span class="hljs-function">                </span><br><span class="hljs-function">                * 中文乱码问题：</span><br><span class="hljs-function">* get方式：tomcat 8 已经将get方式乱码问题解决了</span><br><span class="hljs-function">* post方式：会乱码</span><br><span class="hljs-function">* 解决：在获取参数前，设置request的编码request.<span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(<span class="hljs-string">&quot;utf-8&quot;</span>)</span></span>;<br><br><br><br></code></pre></td></tr></table></figure><p>请求转发：一种在服务器内部的资源跳转方式</p><pre><code>           1. 步骤：                    1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                        2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) </code></pre><ol start="2"><li><p>特点：</p><pre><code>         1. 浏览器地址栏路径不发生变化         2. 只能转发到当前服务器内部资源中。         3. 转发是一次请求</code></pre></li><li><p>共享数据：</p><pre><code> * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法：     1. void setAttribute(String name,Object obj):存储数据     2. Object getAttitude(String name):通过键获取值     3. void removeAttribute(String name):通过键移除键值对</code></pre><ol start="4"><li>获取ServletContext：<ul><li>ServletContext getServletContext()</li></ul></li></ol></li></ol><h2 id="8-请求转发"><a href="#8-请求转发" class="headerlink" title="8.请求转发"></a>8.请求转发</h2><p>概述：服务器内的资源跳转</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.getRequestDispatcher(<span class="hljs-string">&quot; &quot;</span>).forward(request,response);<br></code></pre></td></tr></table></figure><p>特点：</p><p>1.转发地址栏路径不变</p><p>2.转发只能是服务器内部</p><p>3.转发是一次请求。</p><p><strong>共享数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//存数据到request域中</span><br>request.setAttribute(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;object&quot;</span>);<br><br><span class="hljs-comment">//获取值</span><br>request.getAttribute(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//移除存入的数据</span><br>request.removeAttribute(<span class="hljs-string">&quot;key&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="9-Response"><a href="#9-Response" class="headerlink" title="9.Response"></a>9.Response</h2><h4 id="9-1响应消息：服务器端发送给客户端的数据"><a href="#9-1响应消息：服务器端发送给客户端的数据" class="headerlink" title="9.1响应消息：服务器端发送给客户端的数据"></a>9.1响应消息：服务器端发送给客户端的数据</h4><ul><li>数据格式：<ol><li>响应行<ol><li>组成：协议/版本 响应状态码 状态码描述</li><li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ol><li>状态码都是3位数字 </li><li>分类：<ol><li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li><li>2xx：成功。代表：200</li><li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li><li>4xx：客户端错误。<ul><li>代表：<ul><li>404（请求路径没有对应的资源） </li><li>405：请求方式没有对应的doXxx方法</li></ul></li></ul></li><li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li></ol></li></ol></li></ol></li></ol></li></ul><ol start="2"><li>响应头：<pre><code> 1. 格式：头名称： 值 2. 常见的响应头：     1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式     2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据         * 值：             * in-line:默认值,在当前页面内打开             * attachment;filename=xxx：以附件形式打开响应体。文件下载  3.响应空行  4.响应体:传输的数据</code></pre></li></ol><h4 id="9-2response："><a href="#9-2response：" class="headerlink" title="9.2response："></a>9.2response：</h4><p>功能：设置响应消息</p><pre><code> 1. 设置响应行      1. 格式：HTTP/1.1 200 ok    2. 设置状态码：setStatus(int sc)         2. 设置响应头：setHeader(String name, String value)                        3. 设置响应体：* 使用步骤：    1. 获取输出流        * 字符输出流：PrintWriter getWriter()        * 字节输出流：ServletOutputStream getOutputStream()    2. 使用输出流，将数据输出到客户端浏览器</code></pre><p>​    4.重定向和转发区别：<br>​<br>​        * 重定向的特点:redirect<br>​            1. 地址栏发生变化<br>​            2. 重定向可以访问其他站点(服务器)的资源<br>​            3. 重定向是两次请求。不能使用request对象来共享数据<br>​        * 转发的特点：forward<br>​            1. 转发地址栏路径不变<br>​            2. 转发只能访问当前服务器下的资源<br>​            3. 转发是一次请求，可以使用request对象来共享数据<br>​<br>​         * 路径写法：<br>​            1. 路径分类<br>​                1. 相对路径：通过相对路径不可以确定唯一资源<br>​                    * 如：./index.html<br>​                    * 不以/开头，以.开头路径<br>​<br>                    * 规则：找到当前资源和目标资源之间的相对位置关系<br>                        * ./：当前目录<br>                        * ../:后退一级目录<br>                2. 绝对路径：通过绝对路径可以确定唯一资源<br>                    * 如：<a href="http://localhost/day/responseDemo2">http://localhost/day/responseDemo2</a>        /day/responseDemo2<br>                    * 以/开头的路径</p><pre><code>                * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                    * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                        * 建议虚拟目录动态获取：request.getContextPath()                        * &lt;a&gt; , &lt;form&gt; 重定向...                    * 给服务器使用：不需要加虚拟目录                        * 转发路径      2. 服务器输出字符数据到浏览器        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码</code></pre><p>​<br>​                 //设置头信息告诉浏览器的编码格式<br>​                    response.setHeader(“Content-Type”,”text/html;charset=utf-8”);<br>​               //简单的形式，设置编码，是在获取流之前设置<br>​                                response.setContentType(“text/html;charset=utf-8”);<br>​         3. 服务器输出字节数据到浏览器<br>​            * 步骤：<br>​                1. 获取字节输出流<br>​        2. 输出数据<br>​<br>        4. 验证码<br>            1. 本质：图片<br>            2. 目的：防止恶意表单注册                 </p><h2 id="10-ServletContext对象："><a href="#10-ServletContext对象：" class="headerlink" title="10. ServletContext对象："></a>10. ServletContext对象：</h2><ol><li><p>概念：代表整个web应用，可以和程序的容器(服务器)来通信</p></li><li><p>获取：</p><ol><li>通过request对象获取<br> request.getServletContext();</li><li>通过HttpServlet获取<br> this.getServletContext();</li></ol></li><li><p>功能：</p><ol><li><p>获取MIME类型：</p><ul><li><p>MIME类型:在互联网通信过程中定义的一种文件数据类型</p><ul><li>格式： 大类型/小类型   text/html        image/jpeg</li></ul></li><li><p>获取：String getMimeType(String file)  </p></li></ul></li><li><p>域对象：共享数据</p><ol><li>setAttribute(String name,Object value)</li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li></ol><ul><li>ServletContext对象范围：所有用户所有请求的数据</li></ul></li><li><p>获取文件的真实(服务器)路径</p><ol><li><p>方法：String getRealPath(String path)<br>  String b = context.getRealPath(“/b.txt”);//web目录下资源访问<br>  System.out.println(b);</p><p> String c = context.getRealPath(“/WEB-INF/c.txt”);//WEB-INF目录下的资源访问<br> System.out.println(c);</p><p> String a = context.getRealPath(“/WEB-INF/classes/a.txt”);//src目录下的资源访问<br> System.out.println(a);</p></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven笔记</title>
    <link href="/lizheng/2021/08/20/Maven/"/>
    <url>/lizheng/2021/08/20/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>​    Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。</p><h3 id="1-1-Maven-能解决什么问题"><a href="#1-1-Maven-能解决什么问题" class="headerlink" title="1.1 Maven 能解决什么问题"></a>1.1 Maven 能解决什么问题</h3><p>1、我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用 到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。</p><p> 2、我们辛辛苦苦写好了 Java 文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二 进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代 码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一 个个地去编译，逗电脑玩。</p><p> 3、世界上没有不存在 bug 的代码，计算机喜欢 bug 就和人们总是喜欢美女帅哥一样。为了追求美为 了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 </p><p>4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型 打包，如果是 web 项目，还需要将之发布到服务器，供人蹂躏。</p><p><strong>Maven 就可以解决上面所提到的这些问题。</strong></p><h3 id="1-2Maven-的依赖管理"><a href="#1-2Maven-的依赖管理" class="headerlink" title="1.2Maven 的依赖管理"></a>1.2Maven 的依赖管理</h3><p>​    Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 传统的 WEB 项目中，我们必须将工程所依赖的 jar 包复制到工程中，导致了工程的变得很大。 分析如下：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210720093247042.png" alt="image-20210720093247042"></p><p>​    通过分析发现：maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar 包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文 件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从 而找到这些 jar 包，再把这些 jar 包拿去运行。</p><h3 id="1-3-项目的一键构建"><a href="#1-3-项目的一键构建" class="headerlink" title="1.3 项目的一键构建"></a>1.3 项目的一键构建</h3><p>指的是项目从清理 、编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个 过程称为构建。</p><p> 一键构建 指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作。</p><p> Maven 规范化构建流程如下：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210720093434287.png" alt="image-20210720093434287"></p><h2 id="2-Maven-的安装"><a href="#2-Maven-的安装" class="headerlink" title="2.Maven 的安装"></a>2.Maven 的安装</h2><p>1.官网下载</p><p>2.下载解压安装到目录</p><p>3.配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin 目录之前一级目录）</p><p>4.测试</p><p>通过 mvn -v命令检查 maven 是否安装成功，看到 maven 的版本为 3.5.2 及 java 版本为 1.8 即为安装 成功。 找开 cmd 命令，输入 mvn –v命令</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210720093720476.png" alt="image-20210720093720476"></p><p> <strong>Maven 本地仓库的配置</strong></p><p>本课程是在无网的状态下学习，需要配置老师提供的本地仓库，</p><p>打开 settings.xml文件，配置如下：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210720093901935.png" alt="image-20210720093901935"></p><h2 id="3-Maven核心概念"><a href="#3-Maven核心概念" class="headerlink" title="3. Maven核心概念"></a>3. Maven核心概念</h2><ol><li><p>约定的目录结构 </p></li><li><p>POM </p></li><li><p>坐标</p></li><li><p> 依赖 </p></li><li><p>仓库</p></li><li><p>  声明周期，插件，目标 </p></li><li><p> 继承</p></li><li><p> 聚合 </p></li></ol><p>   <strong>蓝色为比较重要 红色为非常重要</strong></p><h3 id="3-1-第一个Maven工程"><a href="#3-1-第一个Maven工程" class="headerlink" title="3.1. 第一个Maven工程"></a>3.1. 第一个Maven工程</h3><p><img src="E:\Typora\image\image-20210720153208824.png" alt="image-20210720153208824"></p><ul><li>src : 源码</li><li> pom.xml ：Maven工程的核心配置文件 </li><li>main : 存放主程序</li><li> test : 存放测试程序</li><li>java : Java源文件 </li><li>resource : 存放框架或其他配置文件</li></ul><h3 id="3-2-常用Maven命令："><a href="#3-2-常用Maven命令：" class="headerlink" title="3.2. 常用Maven命令："></a>3.2. 常用Maven命令：</h3><ul><li>mvn compile : 编译主程序 </li><li>mvn test-compile :编译测试程序 </li><li>mvn test :执行测试 </li><li>mvn package : 打包 </li><li>mvn clean :清理</li></ul><h3 id="3-3-POM"><a href="#3-3-POM" class="headerlink" title="3.3.POM"></a>3.3.POM</h3><p>POM: Project Object Model 项目对象模型 </p><p>pom.xml: 对于Maven工程师核心配置文件，与构建过程相关的所有设置 都在这个文件中进行配置。后 面的学习都是围绕该配置文件。</p><h3 id="3-4-坐标"><a href="#3-4-坐标" class="headerlink" title="3.4.坐标"></a>3.4.坐标</h3><p> 在Maven中的坐标</p><ul><li>groupid: 公司或组织域名倒序+项目名</li><li>artifactid:模块名</li><li>version:版本</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-仓库"><a href="#3-5-仓库" class="headerlink" title="3.5. 仓库"></a>3.5. 仓库</h3><ol><li><p>仓库的分类</p><p> 本地仓库：当前电脑上部署的仓库项目，为当前电脑上所有Maven工程服务</p><p> 远程仓库：</p><ol><li><p>私服：搭建在局域网环境中，为局域网范围内的所有Maven工程服务</p></li><li><p> 中央仓库：假设在Internet上，为全世界所有Maven工程服务</p></li><li><p> 中央仓库镜像：为了分担中央仓库的访问压力，提高用户体验性 </p></li></ol><p> ​     </p></li></ol><p>2.仓库中保存的内容： </p><ul><li>Maven自身所需的插件</li><li> 第三方框架或工具的jar包</li><li> 我们自己开发的Maven工程</li></ul><h3 id="3-6依赖"><a href="#3-6依赖" class="headerlink" title="3.6依赖"></a>3.6依赖</h3><p> <strong>常见依赖范围对比：</strong></p><p>​    常见的依赖范围有三种：compile , test , provided</p><p>​    provided依赖就比如：Servlet的依赖是由tomcat提供的，我们开发的时候要导入该依赖，但是我们部署的时候，一颗由服务器提供，类似于这种依赖关系 我们会使用provided.</p><p><strong>compile依赖范围</strong><br>       主程序：有效<br>       测试程序：有效<br>       打包：参与<br>       部署：参与<br> <strong>test依赖范围</strong><br>      主程序：无效<br>      测试程序：有效<br>      打包：不参与<br> <strong>provided依赖范围</strong><br>     主程序：有效<br>     测试程序：有效<br>      打包：不参与<br>      部署：不参与，原本的依赖由服务器提供</p><h2 id="4-IDEA中使用Maven"><a href="#4-IDEA中使用Maven" class="headerlink" title="4.IDEA中使用Maven"></a>4.IDEA中使用Maven</h2><p><img src="E:\Typora\image\image-20210720154712963.png" alt="image-20210720154712963"></p><p>Maven home directory: maven的安装目录 </p><p>User settings file：Maven安装目录conf/settings.xml配置文件 </p><p>Local repository: Maven本地仓库的目录位置</p><h3 id="4-1-IDEA中使用Maven命令"><a href="#4-1-IDEA中使用Maven命令" class="headerlink" title="4.1.IDEA中使用Maven命令"></a>4.1.IDEA中使用Maven命令</h3><p><img src="E:\Typora\image\image-20210720160039858.png" alt="image-20210720160039858"></p><h3 id="4-2-导入已存在Maven工程"><a href="#4-2-导入已存在Maven工程" class="headerlink" title="4.2.导入已存在Maven工程"></a>4.2.导入已存在Maven工程</h3><ol><li><p>File —&gt; Project from Existing Source</p><p><img src="E:\Typora\image\image-20210720160135369.png"></p></li><li><p>选择Mven —-&gt; Finish</p></li></ol><p><img src="E:\Typora\image\image-20210720160150197.png" alt="image-20210720160150197"></p><h2 id="5-依赖关系"><a href="#5-依赖关系" class="headerlink" title="5. 依赖关系"></a>5. 依赖关系</h2><h3 id="5-1-依赖的传递性"><a href="#5-1-依赖的传递性" class="headerlink" title="5.1 依赖的传递性"></a>5.1 依赖的传递性</h3><p>通过快捷键：Alt + Ctrl +Shift + U 调出 Maven项目依赖关系，查看第一个 和 第二个Maven项目 间的依赖关系。</p><p><img src="E:\Typora\image\image-20210720161036155.png" alt="image-20210720161036155"></p><h3 id="5-2-依赖排除"><a href="#5-2-依赖排除" class="headerlink" title="5.2 依赖排除"></a>5.2 依赖排除</h3><p>在实际开发中，我们经常会遇到Maven依赖冲突的问题，导致编译时报一些异常，处理依赖冲突问题， 我们可以解除依赖排除。这里我们提供两种方式，第一种是图形化界面操作，第二种是手动添加依赖排 除</p><ol><li><strong>通过IDEA添加依赖排除</strong></li></ol><p><img src="E:\Typora\image\image-20210720161318346.png" alt="image-20210720161318346"></p><p><img src="E:\Typora\image\image-20210720161354997.png" alt="image-20210720161354997"></p><ol start="2"><li><strong>手动依赖排除</strong></li></ol><p>比如我们在FirstMaven中添加对 spring-core的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-依赖原则"><a href="#5-3-依赖原则" class="headerlink" title="5.3 依赖原则"></a>5.3 依赖原则</h3><p>当我们项目中引用了不同版本的jar包，那么传递依赖关系中，被传递的依赖关系如何确定？</p><ol><li><p>就近原则 </p><p><img src="E:\Typora\image\image-20210720162028388.png" alt="image-20210720162028388"></p></li><li><p>先到先得原则</p><p><img src="E:\Typora\image\image-20210720162008577.png" alt="image-20210720162008577"></p></li></ol><h2 id="6-统一管理依赖关系"><a href="#6-统一管理依赖关系" class="headerlink" title="6.统一管理依赖关系"></a>6.统一管理依赖关系</h2><p>版本一直统一管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-1使用properties标签，在其内部使用自定义标签统一声明版本号"><a href="#6-1使用properties标签，在其内部使用自定义标签统一声明版本号" class="headerlink" title="6.1使用properties标签，在其内部使用自定义标签统一声明版本号"></a>6.1使用properties标签，在其内部使用自定义标签统一声明版本号</h3><p><img src="E:\Typora\image\image-20210720162348221.png" alt="image-20210720162348221"></p><h3 id="6-2在需要统一版本的位置，使用-自定义标签名-引用声明的版本号。"><a href="#6-2在需要统一版本的位置，使用-自定义标签名-引用声明的版本号。" class="headerlink" title="6.2在需要统一版本的位置，使用${自定义标签名}引用声明的版本号。"></a>6.2在需要统一版本的位置，使用${自定义标签名}引用声明的版本号。</h3><p><img src="E:\Typora\image\image-20210720162449668.png" alt="image-20210720162449668"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC笔记</title>
    <link href="/lizheng/2021/08/20/JDBC/"/>
    <url>/lizheng/2021/08/20/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h3 id="1-概念：Java-DataBase-Connectivity-Java-数据库连接，-Java语言操作数据库"><a href="#1-概念：Java-DataBase-Connectivity-Java-数据库连接，-Java语言操作数据库" class="headerlink" title="1.概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库"></a>1.概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</h3><ul><li>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li></ul><h3 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2.入门案例"></a>2.入门案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.lizheng.until;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBC</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//注册驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>        Connection conn=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获得连接对象</span><br>             conn = DriverManager.getConnection(<br>                    <span class="hljs-string">&quot;jdbc:mysql://localhost/test?serverTimezone=GMT%2B8&quot;</span>,<br>                    <span class="hljs-string">&quot;root&quot;</span>,<br>                    <span class="hljs-string">&quot;123456&quot;</span><br>            );<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">//定义sql</span><br>        String sql = <span class="hljs-string">&quot;update student set english = 99 where id = 3&quot;</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取执行sql语句的对象</span><br>            Statement statement = conn.createStatement();<br>            <span class="hljs-keyword">int</span> i = statement.executeUpdate(sql);<br>            System.out.println(i);<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//关闭资源</span><br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-jdbc中对象"><a href="#3-jdbc中对象" class="headerlink" title="3.jdbc中对象"></a>3.jdbc中对象</h3><p>1.Class.forName</p><p>JVM加载类的过程：加载，链接，初始化。</p><p>在类的加载器加载指定类的时候，如果该类包含静态代码块，则会执行静态代码块中的代码</p><p>因为jdbc的驱动有多种版本，所有jdbc规范中规定，所有驱动都必须向驱动管理器注册以区分各个版本。</p><ol><li><p>DriverManager：驱动管理对象</p><pre><code> * 功能：     1. 注册驱动：告诉程序该使用哪一个数据库驱动jar         static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。          写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);         通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块          static &#123;                 try &#123;                     java.sql.DriverManager.registerDriver(new Driver());                 &#125; catch (SQLException E) &#123;                     throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                 &#125;             &#125;         注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。     2. 获取数据库连接：         * 方法：static Connection getConnection(String url, String user, String password)          * 参数：             * url：指定连接的路径                 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                 * 例子：jdbc:mysql://localhost:3306/db3                 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称             * user：用户名             * password：密码 </code></pre><ol start="2"><li>Connection：数据库连接对象<ol><li>功能：<ol><li>获取执行sql 的对象<ul><li>Statement createStatement()</li><li>PreparedStatement prepareStatement(String sql)  </li></ul></li><li>管理事务：<ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li><li>提交事务：commit() </li><li>回滚事务：rollback() </li></ul></li></ol></li></ol></li><li>Statement：执行sql的对象<ol><li>执行sql<ol><li>boolean execute(String sql) ：可以执行任意的sql 了解 </li><li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句<ul><li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</li></ul></li><li>ResultSet executeQuery(String sql)  ：执行DQL（select)语句</li></ol></li></ol></li></ol></li><li><p>ResultSet：结果集对象,封装查询结果</p><pre><code> * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据     * Xxx：代表数据类型   如： int getInt() ,    String getString()     * 参数：         1. int：代表列的编号,从1开始   如： getString(1)         2. String：代表列名称。 如： getDouble(&quot;balance&quot;)  * 注意：     * 使用步骤：         1. 游标向下移动一行         2. 判断是否有数据         3. 获取数据        //循环判断游标是否是最后一行末尾。         while(rs.next())&#123;             //获取数据             //6.2 获取数据             int id = rs.getInt(1);             String name = rs.getString(&quot;name&quot;);             double balance = rs.getDouble(3);  5. PreparedStatement：执行sql的对象</code></pre><ol><li>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题<pre><code>         1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a         2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;       2. 解决sql注入问题：使用PreparedStatement对象来解决     3. 预编译的SQL：参数使用?作为占位符     4. 步骤：         1. 导入驱动jar包          2. 注册驱动         3. 获取数据库连接对象 Connection         4. 定义sql             * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;         5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)          6. 给？赋值：             * 方法： setXxx(参数1,参数2)                 * 参数1：？的位置编号 从1 开始                 * 参数2：？的值         7. 执行sql，接受返回结果，不需要传递sql语句         8. 处理结果         9. 释放资源      5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作         1. 可以防止SQL注入         2. 效率更高</code></pre></li></ol></li></ol><h2 id="4-抽取JDBC工具类-：-JDBCUtils"><a href="#4-抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="4.抽取JDBC工具类 ： JDBCUtils"></a>4.抽取JDBC工具类 ： JDBCUtils</h2><ul><li>目的：简化书写</li><li>分析：<ol><li>注册驱动也抽取</li><li>抽取一个方法获取连接对象<ul><li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li><li>解决：配置文件<br>  jdbc.properties<pre><code>  url=  user=  password=</code></pre><ol start="3"><li>抽取一个方法释放资源</li></ol></li></ul></li></ol></li></ul><h3 id="4-1入门案例："><a href="#4-1入门案例：" class="headerlink" title="4.1入门案例："></a>4.1入门案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC工具类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wdzl</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 2.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtil_2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      1.加载配置文件</span><br><span class="hljs-comment">      2.初始化连接池对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        InputStream inputStream = JDBCUtil_2.class.<br>                getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            dataSource = DruidDataSourceFactory.createDataSource(properties);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  获取连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> dataSource.getConnection();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  归还连接对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connection</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection connection)</span></span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection.close();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  归还连接对象，释放stmt对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connection</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> statement</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection connection, Statement statement)</span>  </span>&#123;<br>        <span class="hljs-keyword">if</span> (connection!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (statement!=<span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                statement.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 归还连接对象，释放stmt对象,resultSet对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> connection</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> statement</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> resultSet</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Connection connection, Statement statement, ResultSet resultSet)</span>  </span>&#123;<br>        close(connection,statement);<br>        <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                resultSet.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  获取数据源对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="5-数据库连接池"><a href="#5-数据库连接池" class="headerlink" title="5.数据库连接池"></a>5.数据库连接池</h2><ol><li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><pre><code> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</code></pre></li><li><p>好处：</p><ol><li>节约资源</li><li>用户访问高效</li></ol></li><li><p>实现：</p><ol><li><p>标准接口：DataSource   javax.sql包下的</p><ol><li>方法：<ul><li>获取连接：getConnection()</li><li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li></ul></li></ol></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ol><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ol></li></ol></li><li><p>C3P0：数据库连接池技术</p><ul><li><p>步骤：</p><ol><li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ul></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol></li><li><p>代码：<br>   //1.创建数据库连接池对象<br>  DataSource ds  = new ComboPooledDataSource();<br>  //2. 获取连接对象<br>  Connection conn = ds.getConnection();</p></li></ul></li><li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p><ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol><ul><li>代码：<br>   //3.加载配置文件<br>  Properties pro = new Properties();<br>  InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(“druid.properties”);<br>  pro.load(is);<br>  //4.获取连接池对象<br>  DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br>  //5.获取连接<br>  Connection conn = ds.getConnection();</li></ul><ol start="2"><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取连接池的方法</li></ol></li></ol></li></ol></li></ol><ul><li><p>代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;   <br><span class="hljs-comment">//1.定义成员变量 DataSource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.加载配置文件</span><br>            Properties pro = <span class="hljs-keyword">new</span> Properties();<br>            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;druid.properties&quot;</span>));<br>            <span class="hljs-comment">//2.获取DataSource</span><br>            ds = DruidDataSourceFactory.createDataSource(pro);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(Statement stmt,Connection conn)</span></span>&#123;<br>       <span class="hljs-comment">/* if(stmt != null)&#123;</span><br><span class="hljs-comment">            try &#123;</span><br><span class="hljs-comment">                stmt.close();</span><br><span class="hljs-comment">            &#125; catch (SQLException e) &#123;</span><br><span class="hljs-comment">                e.printStackTrace();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        if(conn != null)&#123;</span><br><span class="hljs-comment">            try &#123;</span><br><span class="hljs-comment">                conn.close();//归还连接</span><br><span class="hljs-comment">            &#125; catch (SQLException e) &#123;</span><br><span class="hljs-comment">                e.printStackTrace();</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;*/</span><br><br>       close(<span class="hljs-keyword">null</span>,stmt,conn);<br>    &#125;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;<br>                 <span class="hljs-keyword">if</span>(rs != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rs.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>           <span class="hljs-keyword">if</span>(stmt != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                stmt.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<span class="hljs-comment">//归还连接</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取连接池方法</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span>  ds;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6-Spring-JDBC"><a href="#6-Spring-JDBC" class="headerlink" title="6.Spring JDBC"></a>6.Spring JDBC</h2><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p><strong>调用JdbcTemplate的方法来完成CRUD的操作</strong></p><ul><li><strong>update():执行DML语句。增、删、改语句</strong></li><li>**queryForMap():**查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul><li>注意：这个方法查询的结果集长度只能是1</li></ul></li><li>**queryForList():**查询结果将结果集封装为list集合<ul><li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li></ul></li><li>**query():**查询结果，将结果封装为JavaBean对象<ul><li><strong>query的参数：RowMapper</strong><ul><li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li><li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li></ul></li></ul></li><li><strong>queryForObject</strong>：查询结果，将结果封装为对象<ul><li>一般用于聚合函数的查询</li></ul></li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.lizheng.jdbc.test;<br><br><span class="hljs-keyword">import</span> cn.lizheng.jdbc.domain.Student;<br><span class="hljs-keyword">import</span> cn.lizheng.jdbc.untils.JDBCUntils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCTest</span> </span>&#123;<br><br>    JdbcTemplate jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUntils.getDataSource());<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>        String sql = <span class="hljs-string">&quot;select * from student where id = ?&quot;</span>;<br><br>        Student students = jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Student&gt;(Student.class), <span class="hljs-number">3</span>);<br><br>        System.out.println(students);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        String sql = <span class="hljs-string">&quot;select * from student &quot;</span>;<br><br>        List&lt;Student&gt; students =jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Student&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br><br>                <span class="hljs-keyword">int</span> id = resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>                String name = resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>                <span class="hljs-keyword">int</span> age = resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>);<br>                String sex = resultSet.getString(<span class="hljs-string">&quot;sex&quot;</span>);<br>                String address = resultSet.getString(<span class="hljs-string">&quot;address&quot;</span>);<br>                <span class="hljs-keyword">int</span> math = resultSet.getInt(<span class="hljs-string">&quot;math&quot;</span>);<br>                <span class="hljs-keyword">int</span> english = resultSet.getInt(<span class="hljs-string">&quot;english&quot;</span>);<br><br>                Student student = <span class="hljs-keyword">new</span> Student(id, name, age, sex, address, math, english);<br>                <span class="hljs-keyword">return</span> student;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">for</span> (Student student : students) &#123;<br>            System.out.println(student);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm笔记</title>
    <link href="/lizheng/2021/08/20/JVM/"/>
    <url>/lizheng/2021/08/20/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>经典面试：</p><blockquote><p>1.jvm的理解？jdk1.8jvm和之前的变化更新</p><p>2.什么是OOM(OUT OF MEMORY),什么是栈溢出？如何分析</p><p>3.常用调优参数有哪些</p><p>4.内存快照如何抓取，怎么分析Dump文件？</p><p>5.类加载器， 双亲委派机制</p><p><a href="https://blog.csdn.net/u012485165/article/details/81079145">JVM常见面试题_u012485165的博客-CSDN博客_jvm面试题</a></p><p><a href="https://blog.csdn.net/zgpeace/article/details/108361686">什么是java OOM Out Of Memory 内存溢出？如何分析及解决oom问题？_架构师易筋-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_18657175/article/details/89366499">问十一：JVM调优常用配置参数有哪些？_向代码提问-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_35717340/article/details/114218083">java 内存快照怎么看_jvm内存快照dump文件太大，怎么分析_瓦克五的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/xmh_sxh_1314/article/details/105588513">jvm类加载详解_xmh_sxh_1314的博客-CSDN博客_jvm类加载</a></p></blockquote><h2 id="1、jvm位置"><a href="#1、jvm位置" class="headerlink" title="1、jvm位置"></a>1、jvm位置</h2><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210514234415886.png" alt="image-20210514234415886"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515155317484.png" alt="image-20210515155317484"></p><p>在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,</p><p>在这里可以认为bin里的就是jvm，</p><p>lib中则是jvm工作所需要的类库，</p><p>而jvm(bin)和lib和起来就称为jre.</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210514235011614.png" alt="image-20210514235011614"></p><p><strong>legal</strong>:该路径存放了JDK各模块的授权文档</p><p>include ：java和jvm交互的头文件</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210514235829745.png" alt="image-20210514235829745"></p><h3 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h3><p>1、Sun公司HotSpot Java Hotspot™ 64-Bit Server VM (build 25.181-b13,mixed mode)<br>2、BEA JRockit</p><ul><li>最快的JVM</li><li>目前：Oracle JRockit </li></ul><p>3、IBM J9VM</p><ul><li>垃圾回收算法很突出</li><li>能保证应用程序在绝大多数情况下实时运行（停顿不超过3毫秒）。</li><li>使用人数较少</li></ul><p>我们目前学习都是: ==Hotspot==</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515152148590.png" alt="image-20210515152148590"></p><p>堆</p><h2 id="2、jvm体系结构"><a href="#2、jvm体系结构" class="headerlink" title="2、jvm体系结构"></a>2、jvm体系结构</h2><h4 id="完整架构图"><a href="#完整架构图" class="headerlink" title="完整架构图"></a>完整架构图</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/architecture.png" alt="architecture"></p><h4 id="手绘架构图"><a href="#手绘架构图" class="headerlink" title="手绘架构图"></a>手绘架构图</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515160456564.png" alt="image-20210515160456564"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515155801558.png" alt="image-20210515155801558"></p><h4 id="构成："><a href="#构成：" class="headerlink" title="构成："></a>构成：</h4><ol><li>==类加载器子系统==</li><li>==运行时数据区==</li><li>==执行引擎(Execution Engine)==</li></ol><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol><li><strong>==第三方插件在执行引擎（Execution Engine）上操作或类加载器上操作==<strong>如</strong>Lombok</strong></li></ol><h2 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h2><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321170145363.png" alt="image-20210321170145363"></p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321170239300.png" alt="image-20210321170239300"></p><ul><li><p>一个类在内存中只有一个class对象</p></li><li><p>一个类被加载后，类的整个结构会被封装到class对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class&lt;Car&gt; carClass = Car.class;<br>        Car car1 = <span class="hljs-keyword">new</span> Car();<br>        Car car2 = <span class="hljs-keyword">new</span> Car();<br>        Car car3 = <span class="hljs-keyword">new</span> Car();<br>        <span class="hljs-comment">//对象是具体的多变的</span><br>        System.out.println(car1.hashCode());<br>        System.out.println(car2.hashCode());<br>        System.out.println(car3.hashCode());<br>        <span class="hljs-comment">//类是唯一的抽象的</span><br>        System.out.println(car1.getClass().hashCode());<br>        System.out.println(car2.getClass().hashCode());<br>        System.out.println(car3.getClass().hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515170401389.png" alt="image-20210515170401389"></p></li></ul><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><ul><li><p>static Class.forName(包名)： ClassNotFoundException异常</p></li><li><p>Class&lt;?&gt; getClass()  类的实例调用</p></li><li><p>类名.class   最可靠，性能最高</p></li><li><p>基本类型包装类：TYPE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetClassMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Student();<br>        System.out.println(<span class="hljs-string">&quot;这个人&quot;</span>+person.name);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方式一：Class.forName(包名)</span><br><span class="hljs-comment">         */</span><br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.jkxljc.reflection.Student&quot;</span>);<br>        System.out.println(c1.hashCode());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方式二：Class&lt;?&gt; getClass()</span><br><span class="hljs-comment">         */</span><br>        Class c2 = person.getClass();<br>        System.out.println(c2.hashCode());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         方式三：类名.class</span><br><span class="hljs-comment">         */</span><br>        Class c3 = Student.class;<br>        System.out.println(c3.hashCode());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        方法四：基本类型包装类：TYPE</span><br><span class="hljs-comment">         */</span><br>        Class&lt;Integer&gt; c4 = Integer.TYPE;<br>        System.out.println(c4.hashCode());<br>        System.out.println(c4);<br>         <span class="hljs-comment">//获取父类class对象</span><br>        Class c5 = c2.getSuperclass();<br>        System.out.println(c5);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="拥有class对象的类型"><a href="#拥有class对象的类型" class="headerlink" title="拥有class对象的类型"></a>拥有class对象的类型</h5><ol><li><p>class：外嵌类(embedded class)，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</p></li><li><p>interface：接口</p></li><li><p>数组：[] array</p></li><li><p>enu：枚举</p></li><li><p>annotation：注解@interface</p></li><li><p>primitive type：基本数据类型</p></li><li><p>void ：类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">getType</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c1 = Object.class;<span class="hljs-comment">//类</span><br>        Class c2 = Comparable.class;<span class="hljs-comment">//接口</span><br>        Class c3 = <span class="hljs-keyword">int</span>[].class;<span class="hljs-comment">//一维数组</span><br>        Class c4 = <span class="hljs-keyword">int</span>[][].class;<span class="hljs-comment">//二维数组</span><br>        Class c5 = ElementType.class;<span class="hljs-comment">//枚举类型</span><br>        Class c6 = Integer.class;<span class="hljs-comment">//基本数据类型</span><br>        Class c7 = <span class="hljs-keyword">void</span>.class;<span class="hljs-comment">//void</span><br>        Class c8 = Class.class;<span class="hljs-comment">//Class</span><br>        System.out.println(c1);<br>        System.out.println(c2);<br>        System.out.println(c3);<br>        System.out.println(c4);<br>        System.out.println(c5);<br>        System.out.println(c6);<br>        System.out.println(c7);<br>        System.out.println(c8);<br><span class="hljs-comment">//只要元素类型和维度一致，就是同一个class</span><br>        <span class="hljs-keyword">int</span>[] a=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br>        System.out.println(a.getClass().hashCode());<br>        System.out.println(b.getClass().hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="内存分析："><a href="#内存分析：" class="headerlink" title="内存分析："></a>内存分析：</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321174216456.png" alt="image-20210321174216456"></p><ul><li>方法区是特殊的堆</li></ul><h4 id="类的加载过程："><a href="#类的加载过程：" class="headerlink" title="类的加载过程："></a>类的加载过程：</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515171428700.png" alt="image-20210515171428700"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321174432539.png" alt="image-20210321174432539"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321174537637.png" alt="image-20210321174537637"></p><h5 id="类的初始化："><a href="#类的初始化：" class="headerlink" title="类的初始化："></a>类的初始化：</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321175722487.png" alt="image-20210321175722487"></p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="类加载"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321180111965.png" alt="image-20210321180111965"></p><h5 id="加载class文件"><a href="#加载class文件" class="headerlink" title="加载class文件"></a>加载class文件</h5><h4 id="new的全过程"><a href="#new的全过程" class="headerlink" title="new的全过程"></a>new的全过程</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515165036739.png" alt="image-20210515165036739"></p><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321180222575.png" alt="image-20210321180222575"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210321195912116.png" alt="image-20210321195912116"></p><h5 id="1、JVM自带加载器"><a href="#1、JVM自带加载器" class="headerlink" title="1、JVM自带加载器"></a>1、JVM自带加载器</h5><h5 id="2、启动类-根-加载器——Bootstrap"><a href="#2、启动类-根-加载器——Bootstrap" class="headerlink" title="2、启动类(根)加载器——Bootstrap"></a>2、启动类(根)加载器——Bootstrap</h5><ul><li>rt.jar包下</li></ul><h5 id="3、扩展类加载器——Exclus"><a href="#3、扩展类加载器——Exclus" class="headerlink" title="3、扩展类加载器——Exclus"></a>3、扩展类加载器——Exclus</h5><ul><li>ext下</li></ul><h5 id="4、应用程序加载器-系统-—App"><a href="#4、应用程序加载器-系统-—App" class="headerlink" title="4、应用程序加载器(系统)—App"></a>4、应用程序加载器(系统)—App</h5><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class&lt;Car&gt; carClass = Car.class;<br>        <span class="hljs-comment">//系统App加载器 sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>        System.out.println(carClass.getClassLoader());<br>        <span class="hljs-comment">//扩展类加载器--sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br>        System.out.println(carClass.getClassLoader().getParent());<br>        <span class="hljs-comment">//启动类(根)加载器——Bootstrap--无法获得但存在---null  rt.jar</span><br>        System.out.println(carClass.getClassLoader().getParent().getParent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取系统加载器---sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>      ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>      System.out.println(systemClassLoader);<br>      <span class="hljs-comment">//扩展类加载器---sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br>      ClassLoader parent = systemClassLoader.getParent();<br>      System.out.println(parent);<br>      <span class="hljs-comment">//获取根加载器(引导类)   c/c++ 无法查看</span><br>      ClassLoader root = parent.getParent();<br>      System.out.println(root);<span class="hljs-comment">//null</span><br>      <span class="hljs-comment">//测试当前类的加载器---系统加载器---sun.misc.Launcher$AppClassLoader@18b4aac2</span><br>      ClassLoader classLoader = Class.forName(<span class="hljs-string">&quot;com.jkxljc.reflection.GetLoader&quot;</span>).getClassLoader();<br>      System.out.println(classLoader);<br>      <span class="hljs-comment">//测试jdk内置的类--根加载器(引导类)   c/c++ 无法查看</span><br>      ClassLoader jdkClassLoader = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();<br>      System.out.println(jdkClassLoader);<br>      <span class="hljs-comment">//测试系统类加载器可以获得的路径</span><br>      String property = System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br>      System.out.println(property);<br></code></pre></td></tr></table></figure><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/classloader.png" alt="classloader"></p><p>==<strong>一个自己定义的类，要想加载，它会向类加载器发送请求，</strong>==</p><p>==<strong>类加载请i收到请求后，会向上委托给父类加载器完成，一直向上委托直到启动类加载器(根)，</strong>==</p><p>==<strong>启动加载器检查是否可以加载此类，(rt.jar包下找)，可以就使用根加载器加载，否则抛出异常，通知子加载器加载</strong>==</p><p>如果父类加载器有这个类， 自己写的就失效了，监测安全性</p><ul><li>防止重复加载同一个<code>.class</code>。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全</li><li>保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.class</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。</li><li>不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ul><h2 id="4、沙箱安全机制"><a href="#4、沙箱安全机制" class="headerlink" title="4、沙箱安全机制"></a>4、沙箱安全机制</h2><p><strong>==Java安全模型的核心就是Java沙箱(sandbox) ,==</strong></p><h3 id="简述："><a href="#简述：" class="headerlink" title="简述："></a>简述：</h3><ul><li><p>沙箱是一个限制程序运行的环境。</p></li><li><p>沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。</p></li><li><p>**==沙箱主要限制系统资源访问==**，</p><ul><li>系统资源包括：CPU、内存、文件系统、网络。</li><li>不同级别的沙箱对这些资源访问的限制也可以不一样。</li></ul></li><li><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p></li><li><p>在Java中将执行程序分成本地代码和远程代码两种，</p><ul><li>本地代码默认视为可信任的，而远程代码则被看作是不受信的。</li><li>对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱Sandbox)机制。</li></ul></li></ul><h3 id="安全模型："><a href="#安全模型：" class="headerlink" title="安全模型："></a>安全模型：</h3><h4 id="JDK1-0安全模型"><a href="#JDK1-0安全模型" class="headerlink" title="JDK1.0安全模型"></a>JDK1.0安全模型</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/jdk1.png" alt="jdk1"></p><ul><li>但如此严格的安全机制也给程序的功能扩展带来障碍，</li><li>比如当用户希望远程代码访问本地系统的文件时候，就无法实现</li></ul><h4 id="JDK1-1安全模型"><a href="#JDK1-1安全模型" class="headerlink" title="JDK1.1安全模型"></a>JDK1.1安全模型</h4><ul><li><p>相对于jdk1.0增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/jdk2.png" alt="jdk2"></p></li></ul><h4 id="JDK1-2安全模型"><a href="#JDK1-2安全模型" class="headerlink" title="JDK1.2安全模型"></a>JDK1.2安全模型</h4><ul><li><p>再次改进了安全机制，增加了**==代码签名==**。</p></li><li><p>不论本地代码或是远程代码，都会按照用户的安全策略设定，</p></li><li><p>由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/jdk3%E3%80%81.png" alt="jdk3、"></p></li></ul><h4 id="jdk-1-6安全模型"><a href="#jdk-1-6安全模型" class="headerlink" title="jdk 1.6安全模型"></a>jdk 1.6安全模型</h4><ul><li><p>引入了域(Domain)的概念。</p></li><li><p>JVM会把所有代码加载到不同的系统域和应用域,</p><ul><li>系统域部分专门负责与关键资源进行交互，</li><li>各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</li></ul></li><li><p>虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。</p></li><li><p>存在于不同域中的类文件就具有了当前域的全部权限，如下图所示</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/JDK6.png" alt="JDK6"></p></li></ul><h3 id="沙箱的基本组件"><a href="#沙箱的基本组件" class="headerlink" title="沙箱的基本组件"></a>沙箱的基本组件</h3><h4 id="字节码校验器-bytecode-verifier"><a href="#字节码校验器-bytecode-verifier" class="headerlink" title="字节码校验器(bytecode verifier) :"></a>字节码校验器(bytecode verifier) :</h4><ul><li>确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。</li><li>==<strong>但并不是所有的类文件都会经过字节码校验，比如核心类。</strong>==</li></ul><h4 id="类裝载器-class-loader"><a href="#类裝载器-class-loader" class="headerlink" title="类裝载器(class loader) :"></a>类裝载器(class loader) :</h4><h5 id="其中类装载器在3个方面对Java沙箱起作用"><a href="#其中类装载器在3个方面对Java沙箱起作用" class="headerlink" title="其中类装载器在3个方面对Java沙箱起作用"></a>其中类装载器在3个方面对Java沙箱起作用</h5><ol><li>它防止恶意代码去干涉善意的代码;//双亲委派</li><li>它守护了被信任的类库边界;</li><li>它将代码归入保护域,确定了代码可以进行哪些操作。</li></ol><p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， </p><p>每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。<br>类装载器采用的机制是==双亲委派==模式。</p><ol><li>从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;</li><li>由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li></ol><h4 id="存取控制器-access-controller"><a href="#存取控制器-access-controller" class="headerlink" title="存取控制器(access controller) :"></a>存取控制器(access controller) :</h4><ul><li>存取控制器可以控制核心API对操作系统的存取权限==，而这个控制的策略设定,可以由用户指定。==</li></ul><h4 id="安全管理器-security-manager"><a href="#安全管理器-security-manager" class="headerlink" title="安全管理器(security manager) :"></a>安全管理器(security manager) :</h4><ul><li>是==核心API和操作系统==之间的主要接口。实现权限控制，比存取控制器优先级高。</li></ul><h4 id="安全软件包-security-package"><a href="#安全软件包-security-package" class="headerlink" title="安全软件包(security package) :"></a>安全软件包(security package) :</h4><p> ==java.security==下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:</p><ul><li>安全提供者</li><li>消息摘要</li><li>数字签名  https</li><li>加密鉴别</li></ul><h2 id="5、Native关键字与PC寄存器，方法区"><a href="#5、Native关键字与PC寄存器，方法区" class="headerlink" title="5、Native关键字与PC寄存器，方法区"></a>5、Native关键字与PC寄存器，方法区</h2><h3 id="5-1、native关键字"><a href="#5-1、native关键字" class="headerlink" title="5.1、native关键字"></a>5.1、native关键字</h3><h4 id="native具体做法"><a href="#native具体做法" class="headerlink" title="native具体做法"></a>native具体做法</h4><ul><li>凡是带了native关键字，说明java作用域已经达不到了，得去调c/c++库</li><li>首先进入本地方法栈，进行登记方法，然后调用JNI接口</li><li>在( Execution Engine )执行引擎执行的时候加载Native Libraies执行对应的方法。</li></ul><h4 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><ul><li>扩展java的使用</li><li>融合不同的编程语言为Java所用，它的初衷是融合C/C++程序, Java在诞生的时候是C/C++横行的时候，想要立足，必须有调用C、C++的程序，于是就在==内存中专门开辟了块标记区域：本地方法栈，登记native方法处理标记为native的代码，==</li><li>在( Execution Engine )执行引擎执行的时候加载Native Libraies执行对应的方法。</li></ul><h5 id="现状："><a href="#现状：" class="headerlink" title="现状："></a>现状：</h5><ul><li>目前该方法使用的越来越少了，除非是与硬件有关的应用， </li><li>比如通过Java程序驱动打印机或者Java系统管理生产设备，==在企业级应用中已经比较少见。==</li><li>因为现在的异构领域间通信很发达，比如可以使用Socket通信,也可以使用Web Service等等!</li></ul><h3 id="5-2、pc寄存器"><a href="#5-2、pc寄存器" class="headerlink" title="5.2、pc寄存器"></a>5.2、pc寄存器</h3><p><strong>程序计数器: Program Counter Register</strong></p><ul><li>每个线程都有一个程序计数器，是线程私有的，记住下一条jvm指令的执行地址</li><li>就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，</li><li>在执行引擎读取下一条指令, ==是一个非常小的内存空间，几乎可以忽略不计==</li></ul><p><strong>特点：</strong>1.线程私有的 2.不存在内存的溢出。</p><h3 id="5-3、方法区–Method-Area"><a href="#5-3、方法区–Method-Area" class="headerlink" title="5.3、方法区–Method Area"></a>5.3、方法区–Method Area</h3><h4 id="代码的内存分析"><a href="#代码的内存分析" class="headerlink" title="代码的内存分析"></a>代码的内存分析</h4><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;叫一声&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PetTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Pet dog = <span class="hljs-keyword">new</span> Pet();<br>        dog.name=<span class="hljs-string">&quot;旺财&quot;</span>;<br>        dog.age=<span class="hljs-number">12</span>;<br>        Pet cat = <span class="hljs-keyword">new</span> Pet();<br>        cat.name=<span class="hljs-string">&quot;小慧&quot;</span>;<br>        cat.age=<span class="hljs-number">2</span>;<br>        dog.call();<br>        cat.call();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="内存图："><a href="#内存图：" class="headerlink" title="内存图："></a>内存图：</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515220439658.png" alt="image-20210515220439658"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>被所有线程共享,</p></li><li><p>本质是一个特殊的堆</p></li><li><p>所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,</p></li><li><p>简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;</p></li><li><p><strong>静态变量或方法、常量、类信息(构造方法、接口定义，成员属性或方法)、运行时的常量池存在方法区中，</strong></p></li><li><p><strong>==但是实例变量存在堆内存中，和方法区无关==</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/new2.png" alt="new2"></p></li></ul><h2 id="6、栈stack"><a href="#6、栈stack" class="headerlink" title="6、栈stack"></a>6、栈stack</h2><p>程序=数据结构+算法</p><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><ul><li>一种数据结构</li><li>先进后出，后进先出，类似于桶(FILO)</li><li>队列：先进先出(FIFO)</li><li>栈内存：主管程序的运行，生命周期和线程同步</li><li>线程结束，栈内存也就释放over</li><li>线程级别的</li><li>栈不存在垃圾回收机制–GC</li><li>基本数据类型包括数值+对象引用+实例的方法</li></ul><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈满了: StackOverflowError</p><p>是个错误，不是异常</p><p>A调用B方法，B又调用A方法，不停的压栈，栈内存溢出</p><p>递归</p><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><h4 id="栈参数"><a href="#栈参数" class="headerlink" title="栈参数"></a>栈参数</h4><p>==栈帧==</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/stack1.png" alt="stack1"></p><ul><li>栈底部子帧指向上一个栈的方法 </li><li>上一个栈的父帧指向栈底部方法</li><li>程序正在运行的方法在栈顶</li></ul><h4 id="栈和方法区和堆的交互关系："><a href="#栈和方法区和堆的交互关系：" class="headerlink" title="==栈和方法区和堆的交互关系：=="></a><strong>==栈和方法区和堆的交互关系：==</strong></h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/stack2.png" alt="stack2"></p><h4 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="==对象实例化的过程=="></a><strong>==对象实例化的过程==</strong></h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210515232127476.png" alt="image-20210515232127476"></p><p>Cat cat = new Cat()的过程</p><ol><li><p>JVM会根据指定路径读取Cat.class文件，并加载进内存，有父类（如：Animal）的情况下，==会先加载父类==的.class文件（即Animal.class）。</p></li><li><p>在堆内存开辟空间，分配地址</p></li><li><p>在堆对象空间中，对对象的属性进行默认初始化。</p><ul><li>调用对应构造函数进行初始化，这个例子中，调用的就是，无参构造函数</li><li>在构造函数中，第一行会到调用父类中构造函数进行初始化</li><li>父类初始化完毕后，再对子类属性进行显示初始化</li></ul></li><li><p>再进行子类构造函数的特定初始化</p></li><li><p>初始化完毕后，将地址赋值给引用变量(栈)。</p></li></ol><p>栈中具体存的东西，如何存</p><p>[对象的实例化、内存布局和访问定位](<a href="https://www.cnblogs.com/jiuxing/p/13891618.html">[JVM第六篇–对象]对象的实例化、内存布局和访问定位 - 就行222 - 博客园 (cnblogs.com)</a>)</p><h2 id="7、堆-Heap"><a href="#7、堆-Heap" class="headerlink" title="7、堆(Heap)"></a>7、堆(Heap)</h2><h3 id="7-1、概述："><a href="#7-1、概述：" class="headerlink" title="7.1、概述："></a>7.1、概述：</h3><ul><li>一个JVM只有一个堆内存</li><li>堆内存大小可以共享</li><li>类加载器读取了类文件后，将类，方法，常量，变量，保存所有引用类型的真实对象放置堆中</li><li>堆中的东西使用完之后不能立即释放，通过GC线程回收释放</li><li>默认堆内存大小：新生代：老年代=1：2，但是可通过-XX:NewRatio来调整</li></ul><h3 id="7-2、堆内存划分"><a href="#7-2、堆内存划分" class="headerlink" title="7.2、堆内存划分"></a>7.2、堆内存划分</h3><h4 id="简略图示："><a href="#简略图示：" class="headerlink" title="简略图示："></a>简略图示：</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516153313735.png" alt="image-20210516153313735"></p><p><img src="F:%5C%E8%B5%84%E6%96%99%5Cmd%5CJVM.assets%5Cimage-20210516163241167.png" alt="image-20210516163241167"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516162950882.png" alt="image-20210516162950882"></p><p>==GC垃圾回收主要在伊甸园区和养老区==</p><p>内存满了，OOM,堆内存不够 java.lang.OutOfMemoryError: Java heap space</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s=<span class="hljs-string">&quot;asdhjkhjl;dsjvl;k&quot;</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            s+=s+<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">888888888</span>)+<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516153923092.png" alt="image-20210516153923092"></p><p><strong>==jdk8以后，永久存储区改为元空间==</strong></p><h4 id="1、新生区-伊甸园区-：young-New"><a href="#1、新生区-伊甸园区-：young-New" class="headerlink" title="1、新生区(伊甸园区)：young/New"></a>1、新生区(伊甸园区)：young/New</h4><ul><li><p>年轻代主要存放新创建的对象，内存⼤⼩相对会⽐较⼩，垃圾回收会⽐较频繁。</p></li><li><p>年轻代分成1 个Eden Space和2个Suvivor Space（命名为A和B）。</p></li><li><p>当对象在堆创建时，将进⼊年轻代的Eden Space。垃圾回收器进⾏垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则 复制到B Suvivor Space，</p></li><li><p>如果B Suvivor Space已经满，则复制到Old Gen。</p></li><li><p>同时，==在扫描Suvivor Space时，如果对象已经经过了⼏次的扫描仍然存活，JVM认为其为⼀个持久化对象，则将其移到Old Gen==。</p></li><li><p>扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的⻆⾊（即下次垃圾 回收时会扫描Eden Space和B Suvivor Space。这么做主要是为了==减少内存碎⽚==的产⽣</p></li><li><p>类：诞生和成长的地方，甚至死亡，只有极其少的一部分才会进入养老区</p></li><li><p>伊甸园，所有的对象都是在伊甸园区new出来的； </p></li><li><p>幸存者区（0，1）:不是固定的，可互换身份（from，to）to始终为空</p></li><li><p>==经过研究，99%的对象都是临时对象==；</p></li><li><p>默认的：Eden：FROM:TO=8:1:1,但可通过-XX:SurivorRatio来调整</p></li><li><p>新生代实际可用空间为90%、</p></li></ul><h5 id="调换过程："><a href="#调换过程：" class="headerlink" title="调换过程："></a>调换过程：</h5><ol><li>新生代一个对象先判断大小，超过特定内存的对象直接进入老年代，否则走2</li><li>新生代的minor gc中，一个survivor区数据复制进去，另一个是空的，</li><li>下一次GC时候，有数据的是from，没数据的是to，gc的时候，from和Eden的数据都复制到to中，此时from和to就调换了身份，一直循环</li><li>3中每复制一次，所有对象年龄加1，当任意一个对象复制到一定次数，就被复制到了老年代</li></ol><h4 id="2、老年区-old"><a href="#2、老年区-old" class="headerlink" title="2、老年区 old"></a>2、老年区 old</h4><ul><li>年⽼代主要存放JVM认为⽣命周期⽐较⻓的对象（经过⼏次的Young Gen的垃圾回收后仍然 存在），内存⼤⼩相对会⽐较⼤，垃圾回收也相对没有那么频繁（譬如可能⼏个⼩时⼀次）。</li><li>年⽼代主 要采⽤压缩的⽅式来避免内存碎⽚（将存活对象移动到内存⽚的⼀边，也就是内存整理）。当然，有些 垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进⾏压缩。</li></ul><h4 id="3、永久区-perm"><a href="#3、永久区-perm" class="headerlink" title="3、永久区 perm"></a>3、永久区 perm</h4><h5 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h5><ul><li><p>持久代主要存放类定义、字节码和常量等很少会变更的信息。</p></li><li><p>这个区域常驻内存的。⽤来存放==JDK⾃身携带的Class对象。lnterface元数据==，存储的是==Java 运⾏时的⼀些环境或类信息==，**==这个区域不存在垃圾回收==**。</p></li><li><p>关闭VM虚拟就会释放这个区域的内存。</p></li><li><p>OOM出现情况：</p><ul><li>⼀个启动类，加载了⼤量的第三⽅jar包。</li><li>Tomcat部署了太多的应⽤，</li><li>⼤量动态⽣成的反射 类。不断的被加载。直到内存满</li></ul></li></ul><h5 id="发展进程："><a href="#发展进程：" class="headerlink" title="发展进程："></a>发展进程：</h5><ul><li>jdk1.6之前(包含1.6)：永久代，==常量池在⽅法区== </li><li>jdk1.7 ：永久代,但是慢慢的退化了，去永久代，==常量池在堆中== </li><li>jdk1.8之后：⽆永久代，改名元空间(元数据区),==常量池在元空间==<ul><li>jdk1.8引入了一个新的native的内存区块–MetaSpace</li></ul></li></ul><h5 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h5><h6 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTest2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回虚拟机试图使⽤的最⼤内存</span><br>        <span class="hljs-keyword">long</span> max = Runtime.getRuntime().maxMemory();<br>        <span class="hljs-comment">//返回jvm初始化总内存</span><br>        <span class="hljs-keyword">long</span> total=Runtime.getRuntime().totalMemory();<br>        System.out.println(<span class="hljs-string">&quot;max=&quot;</span> + max + <span class="hljs-string">&quot;字节\t&quot;</span> + (max / (<span class="hljs-keyword">double</span>) <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;total=&quot;</span> + total + <span class="hljs-string">&quot;字节\t&quot;</span> + (total / (<span class="hljs-keyword">double</span>)( <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)) + <span class="hljs-string">&quot;MB&quot;</span>);<br>        <span class="hljs-comment">// 默认情况下:分配的总内存是电脑内存的1/4,⽽初始化的内存为1/64</span><br>        <span class="hljs-comment">// -Xms1024m -Xmx1024m -XX:+PrintGCDetails</span><br><span class="hljs-comment">//年轻代：305664K</span><br>    <span class="hljs-comment">//老年代：699392K</span><br>        <span class="hljs-comment">//元空间：4496K</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="配置jvm参数"><a href="#配置jvm参数" class="headerlink" title="配置jvm参数"></a>配置jvm参数</h6><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516165630833.png" alt="image-20210516165630833"></p><h6 id="运行截图："><a href="#运行截图：" class="headerlink" title="运行截图："></a>运行截图：</h6><p><strong>不配置参数：默认</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516182353008.png" alt="image-20210516182353008"></p><p><strong>配置参数：</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516165659359.png" alt="image-20210516165659359"></p><h5 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h5><ul><li><p>元空间：逻辑上存在，物理上不存在；</p></li><li><p>有时候也可称为非堆，但仍是堆</p></li><li><p>永久代(perm gen)Hotpot虚拟机特有的概念</p></li><li><p>jdk1.8之后，jvm调优不用考虑永久代(元空间),元空间基本不会报OOM</p></li><li><p>只受系统内存限制</p></li></ul><h4 id="4、对象进入tenured的条件"><a href="#4、对象进入tenured的条件" class="headerlink" title="4、对象进入tenured的条件"></a>4、对象进入tenured的条件</h4><p><strong>1、对象经历了15次 Minor GC 依旧存活 (默认值 -XX:MaxTenuringThreshold = 15)</strong></p><p><strong>2、Survivor区中 同龄对象大小超过Survivor区空间的50%,大于此年龄的对象会进入老年代 (动态对象年龄判定) (其实是这个年龄以及低于这个年龄的对象占据超过Survivor 50% 1+2+3大于50% 则大于等于3岁的对象会进入老年代)</strong></p><p>此处可以参考<strong>：</strong><a href="https://blog.csdn.net/u014493323/article/details/82921740">https://blog.csdn.net/u014493323/article/details/82921740</a></p><p><strong>3、Minor GC后对象大小大于Survivor大小，会进入老年代 (空间担保机制)</strong></p><p><strong>4、大对象直接进入老年代 (-XX:PretenureSizeThreshold=1M 只对Serial和ParNew两款收集器有效)</strong></p><h3 id="7-3、堆内存调优"><a href="#7-3、堆内存调优" class="headerlink" title="7.3、堆内存调优"></a>7.3、堆内存调优</h3><h4 id="常见参数："><a href="#常见参数：" class="headerlink" title="常见参数："></a>常见参数：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms设置初始化内存分配⼤⼩,<span class="hljs-number">1</span>/<span class="hljs-number">64</span><br>-Xmx设置最⼤分配内存,默认<span class="hljs-number">1</span>/<span class="hljs-number">4</span><br>-XX:+PrintGCDetails <span class="hljs-comment">//打印GC垃圾回收信息</span><br>-XX:+HeapDumpOnOutOfMemoryError <span class="hljs-comment">//oom DUMP</span><br>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError<br>-XX:NewRatio=老年代比例分数 来调整新生代老年代比例  <br>-XX:SurivorRatio来调整幸存区与eden的比例    默认该值是<span class="hljs-number">8</span>，即Egen：from：to=<span class="hljs-number">8</span>：<span class="hljs-number">1</span>：<span class="hljs-number">1</span><br>-XX:PretenureSizeThreshold=字节数：配置超过大对象内存参数直接进入老年代<br>-XX:MaxTenuringThreshold=数字：任意对象到达复制次数进入老年代 默认<span class="hljs-number">15</span><br>-XX:MaxMetaspaceSize：最大元空间大小，默认为unlimited(只受系统内存限制)<br>-Xss设置每个线程的堆栈⼤⼩。<br>-XX:MaxPermSize设置永久代最⼤空间⼤⼩<br>-XX:PermSize设置永久代最⼩空间⼤⼩。<br>-XX:MaxNewSize设置新⽣代最⼤空间⼤⼩。<br>-XX:NewSize设置新⽣代最⼩空间⼤⼩。<br>-Xmn堆中新⽣代初始及最⼤⼤⼩（NewSize和MaxNewSize为其细化）。<br></code></pre></td></tr></table></figure><h4 id="OOM诊断"><a href="#OOM诊断" class="headerlink" title="OOM诊断"></a>OOM诊断</h4><h5 id="常见OOM问题"><a href="#常见OOM问题" class="headerlink" title="常见OOM问题"></a>常见OOM问题</h5><blockquote><p>运行时常量池导致的溢出，设置持久代内存-XX:MaxPermSize参数，通常可以解决OOM</p><p>超过虚拟机允许大小的内存，出现OOM</p><p>堆内存空间不足，设置heapspace XMx参数增加堆内存，通常可以解决OOM</p></blockquote><h5 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h5><p><strong>在⼀个项⽬中，突然出现了OOM故障，那么该如何排除~</strong></p><p><strong>研究为什么出错 能够看到代码第⼏⾏出错：</strong></p><ul><li><p>内存快照分析⼯具：(ECLIPSE)MAT、Jprofiler </p></li><li><p>Debug，⼀⾏⾏分析代码，项目上线时无法使用</p></li></ul><h5 id="MAT、Jprofiler作⽤"><a href="#MAT、Jprofiler作⽤" class="headerlink" title="MAT、Jprofiler作⽤"></a>MAT、Jprofiler作⽤</h5><ul><li>分析Dump内存⽂件,快速定位内存泄露 </li><li>获得堆中的数据 </li><li>获得⼤的对象 ……</li></ul><h5 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h5><ol><li><p>尝试扩⼤堆内存看结果 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms1m -Xmx8m<br></code></pre></td></tr></table></figure></li><li><p>若仍有问题，就要分析内存，看⼀下那个地⽅出现了问题（专业⼯具）jprofier、</p></li><li><p>没问题，就是内存太小，调整即可</p></li></ol><h5 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h5><h6 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTest</span> </span>&#123;<br><span class="hljs-comment">//    -Xms8m -Xmx8m -XX:+PrintGCDetails</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        <span class="hljs-keyword">String</span> s=<span class="hljs-string">&quot;asdhjkhjl;dsjvl;k&quot;</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            s+=s+<span class="hljs-keyword">new</span> <span class="hljs-type">Random</span>().nextInt(<span class="hljs-number">888888888</span>)+<span class="hljs-keyword">new</span> <span class="hljs-type">Random</span>().nextInt(<span class="hljs-number">999999999</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="配置参数："><a href="#配置参数：" class="headerlink" title="配置参数："></a>配置参数：</h6><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516183041586.png" alt="image-20210516183041586"></p><h6 id="运行情况："><a href="#运行情况：" class="headerlink" title="运行情况："></a>运行情况：</h6><p><strong>不配置参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3332</span>)<br>at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="hljs-number">124</span>)<br>at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="hljs-number">674</span>)<br>at java.lang.StringBuilder.append(StringBuilder.java:<span class="hljs-number">208</span>)<br>at HeapTest.main(HeapTest.java:<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p><strong>配置参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 1536K-&gt;504K(2048K)] 1536K-&gt;644K(7680K), <span class="hljs-number">0.0394235</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.04</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1913K-&gt;481K(2048K)] 2053K-&gt;936K(7680K), <span class="hljs-number">0.0008421</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1901K-&gt;344K(2048K)] 2356K-&gt;1625K(7680K), <span class="hljs-number">0.0007762</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1522K-&gt;408K(2048K)] 3908K-&gt;3345K(7680K), <span class="hljs-number">0.0016787</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1018K-&gt;472K(2048K)] 5059K-&gt;4513K(7680K), <span class="hljs-number">0.0006704</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 472K-&gt;440K(2048K)] 4513K-&gt;4481K(7680K), <span class="hljs-number">0.0006107</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 440K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 4041K-&gt;2252<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 4481K-&gt;2252<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3259K-&gt;3259<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0051779 secs] [Times: user</span>=<span class="hljs-number">0.09</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 1147K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 5563K-&gt;2802<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 6711K-&gt;2802<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3275K-&gt;3275<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0065831 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 60K-&gt;0K(2048K)] 5070K-&gt;5009K(7680K), <span class="hljs-number">0.0003115</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Ergonomics)</span> [PSYoungGen: 0K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 5009K-&gt;3905<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 5009K-&gt;3905<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3275K-&gt;3275<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0068917 secs] [Times: user</span>=<span class="hljs-number">0.09</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 3905K-&gt;3905K(7680K), <span class="hljs-number">0.0003128</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[<span class="hljs-function">Full <span class="hljs-title">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0<span class="hljs-title">K</span><span class="hljs-params">(2048K)</span>] [ParOldGen: 3905K-&gt;3886<span class="hljs-title">K</span><span class="hljs-params">(5632K)</span>] 3905K-&gt;3886<span class="hljs-title">K</span><span class="hljs-params">(7680K)</span>, [Metaspace: 3275K-&gt;3275<span class="hljs-title">K</span><span class="hljs-params">(1056768K)</span>], 0.0061927 secs] [Times: user</span>=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 2048K, used 64K [<span class="hljs-number">0x00000000ffd80000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 1536K, <span class="hljs-number">4</span>% used [<span class="hljs-number">0x00000000ffd80000</span>,<span class="hljs-number">0x00000000ffd90310</span>,<span class="hljs-number">0x00000000fff00000</span>)<br>  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>  to   space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff00000</span>,<span class="hljs-number">0x00000000fff80000</span>)<br> ParOldGen       total 5632K, used 3886K [<span class="hljs-number">0x00000000ff800000</span>, <span class="hljs-number">0x00000000ffd80000</span>, <span class="hljs-number">0x00000000ffd80000</span>)<br>  object space 5632K, <span class="hljs-number">68</span>% used [<span class="hljs-number">0x00000000ff800000</span>,<span class="hljs-number">0x00000000ffbcb838</span>,<span class="hljs-number">0x00000000ffd80000</span>)<br> Metaspace       used 3333K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 362<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"><span class="hljs-title">Exception</span> <span class="hljs-title">in</span> <span class="hljs-title">thread</span> &quot;<span class="hljs-title">main</span>&quot; <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">OutOfMemoryError</span>: <span class="hljs-title">Java</span> <span class="hljs-title">heap</span> <span class="hljs-title">space</span></span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">Arrays</span>.<span class="hljs-title">copyOf</span>(<span class="hljs-title">Arrays</span>.<span class="hljs-title">java</span>:3332)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">ensureCapacityInternal</span>(<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">java</span>:124)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">append</span>(<span class="hljs-title">AbstractStringBuilder</span>.<span class="hljs-title">java</span>:674)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">StringBuilder</span>.<span class="hljs-title">append</span>(<span class="hljs-title">StringBuilder</span>.<span class="hljs-title">java</span>:208)</span><br><span class="hljs-class"><span class="hljs-title">at</span> <span class="hljs-title">HeapTest</span>.<span class="hljs-title">main</span>(<span class="hljs-title">HeapTest</span>.<span class="hljs-title">java</span>:15)</span><br><span class="hljs-class"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 1</span><br></code></pre></td></tr></table></figure><ul><li>年轻代，老年代都走不动了，无法清理了，爆出OOM</li></ul><h4 id="Jprofiler"><a href="#Jprofiler" class="headerlink" title="Jprofiler"></a>Jprofiler</h4><h5 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Dump</span><br><span class="hljs-comment"> *  -Xms设置初始化内存分配⼤⼩,1/64</span><br><span class="hljs-comment"> *  -Xmx设置最⼤分配内存,默认1/4</span><br><span class="hljs-comment"> * -XX:+PrintGCDetails //打印GC垃圾回收信息</span><br><span class="hljs-comment"> * -XX:+HeapDumpOnOutOfMemoryError //oom DUMP</span><br><span class="hljs-comment"> * -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTest3</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 1m</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ArrayList&lt;HeapTest3&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                list.add(<span class="hljs-keyword">new</span> HeapTest3());<span class="hljs-comment">//错误位置</span><br>                 count++;<br>                &#125;<br>             &#125; <span class="hljs-keyword">catch</span> (Error e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;count:&quot;</span>+count);<br>            e.printStackTrace();<br>         &#125;<br>        <span class="hljs-comment">// Throwable</span><br>         <span class="hljs-comment">// Exception</span><br>        <span class="hljs-comment">// error</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="配置参数–Dump文件"><a href="#配置参数–Dump文件" class="headerlink" title="配置参数–Dump文件"></a>配置参数–Dump文件</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516184714249.png" alt="image-20210516184714249"></p><h5 id="软件分析"><a href="#软件分析" class="headerlink" title="软件分析"></a>软件分析</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516184809000.png" alt="image-20210516184809000"></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516184836248.png" alt="image-20210516184836248"></p><h2 id="8、垃圾回收"><a href="#8、垃圾回收" class="headerlink" title="8、垃圾回收"></a>8、垃圾回收</h2><h3 id="概述：-3"><a href="#概述：-3" class="headerlink" title="概述："></a>概述：</h3><p><strong>==GC(Garbage collection)==</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516214215293.png" alt="image-20210516214215293"></p><p><strong>jvm在进行Garbage collection回收时，并不是对三个区域统一回收，大部分时候，只针对新生代</strong></p><ul><li>新生代</li><li>幸存区(from,to)</li><li>老年代</li></ul><h4 id="GC两种类型："><a href="#GC两种类型：" class="headerlink" title="GC两种类型："></a>GC两种类型：</h4><ul><li>轻gc(minor)–新生代</li><li>重GC(FULL)–老年代</li></ul><h4 id="GC-garbage-collection-面试题："><a href="#GC-garbage-collection-面试题：" class="headerlink" title="GC(garbage collection)面试题："></a>GC(garbage collection)面试题：</h4><ul><li>JVM的内存模型和分区~详细到每个区放什么？ </li><li>堆⾥⾯的分区有哪些？(Eden、form、to、⽼年区），说说它们的特点。 </li><li>GC的算法有哪些？标记清除法，标记压缩，复制算法，引⽤计数，怎么⽤的？ </li><li>轻GC和重GC分别在什么时候发⽣？    </li></ul><blockquote><p>轻GC发生在年轻代，</p><p>重GC发生情况：</p><ol><li>老年代满</li><li>持久代满</li><li>System.gc()</li><li>CMS GC出现promotion failed和concurrent mode failure,可能会触发FULLGC</li></ol><ul><li>promotion failed轻gc时幸存区放不下，只能放入老年代，但老年代也放不下</li><li>concurrent mode failure 在执行CMSGC的过程中同时有对象要放入老年代，但此时老年代的空间不足</li></ul><ol start="5"><li>统计得到的MinorGC晋升到老年代的平均大小大于老年代的剩余空间</li></ol><p>注意：RMI来进行RPC或管理的sun jdk应用而言，默认情况会一小时执行一次Full GC，但可调配</p><ul><li>-java-Dsun.rmi.dgc.client.gcinterval=值 FULL GC执行间隔时间</li><li>XX:+DisableExplicitGC 禁止RMI调用System.gc()</li></ul></blockquote><h3 id="GC常用算法："><a href="#GC常用算法：" class="headerlink" title="GC常用算法："></a>GC常用算法：</h3><h4 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h4><p><strong>==拥有一个计数器==</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516220240754.png" alt="image-20210516220240754"></p><p><a href="https://blog.csdn.net/toyijiu/article/details/80309970">参考资料</a></p><p><strong>一般不使用</strong></p><h4 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h4><h5 id="概述：-4"><a href="#概述：-4" class="headerlink" title="概述："></a>概述：</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516222541317.png" alt="image-20210516222541317"></p><h5 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h5><ol><li><p><strong>初始阶段</strong>：</p><p><img src="F:%5C%E8%B5%84%E6%96%99%5Cmd%5CJVM.assets%5Cimage-20210516223515709.png" alt="image-20210516223515709"></p></li><li><p><strong>调换from与to区</strong></p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516223616871.png" alt="image-20210516223616871"></p></li><li><p>**==达到最大复制次数==**，坚持下来的入永久，其他结束使命</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516223745832.png" alt="image-20210516223745832"></p></li></ol><h5 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h5><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul><li>没有多余的内存碎片</li><li>新生代极为适合的一种算法</li></ul><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul><li>to始终为空，浪费了内存空间</li><li>假设对象100%存活，（极端情况），OOM</li></ul><p><a href="%5BGC_4_GC%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95_%E4%BC%8D%E5%8F%B6%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_gc%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%5D(https://blog.csdn.net/u014228375/article/details/68957510)">参考资料</a></p><p><strong>==最佳使用场景：对象存活度较低的新生区==</strong></p><h4 id="3、标记清除算法"><a href="#3、标记清除算法" class="headerlink" title="3、标记清除算法"></a>3、标记清除算法</h4><h5 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516230340352.png" alt="image-20210516230340352"></p><h5 id="清除："><a href="#清除：" class="headerlink" title="清除："></a>清除：</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516230402871.png" alt="image-20210516230402871"></p><p>优点：不需要额外的空间。 </p><p>缺点：两次扫描，严重浪费时间，会产⽣内存碎⽚。</p><p>[参考](<a href="https://www.cnblogs.com/leisurelylicht/p/GC-biao-jiqing-chu-suan-fa-Mark-Sweep-GC.html">1. GC标记-清除算法(Mark Sweep GC) - 暮晨 - 博客园 (cnblogs.com)</a>)</p><h4 id="4、标记压缩算法"><a href="#4、标记压缩算法" class="headerlink" title="4、标记压缩算法"></a>4、标记压缩算法</h4><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516230859330.png" alt="image-20210516230859330"></p><h5 id="先标记清除多次"><a href="#先标记清除多次" class="headerlink" title="先标记清除多次"></a>先标记清除多次</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516231015051.png" alt="image-20210516231015051"></p><h5 id="再统一压缩"><a href="#再统一压缩" class="headerlink" title="再统一压缩"></a>再统一压缩</h5><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516231211943.png" alt="image-20210516231211943"></p><p><a href="%5BJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A32%E4%B9%8B%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E5%92%8C%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95_wang_chao_yang%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/wang_chao_yang/article/details/106464368)">参考:</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩(时间复杂度)</p></li><li><p>内存整齐度：复制算法=标记压缩&gt;标记清除</p></li><li><p>内存利用率：标记压缩=标记清除&gt;复制算法</p></li><li><p>没有最优，只有最合适的，GC也称为==分代收集==算法</p></li><li><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul></li><li><p>老年代：</p><ul><li>区域大，存活率高</li><li>标记清除(内存碎片不是太多)+标记压缩(内存碎片到达一定量级)混合实现</li></ul></li></ul><p>[参考:]([<a href="https://www.jianshu.com/p/1112712c6b92">转]六、GC算法精解（五分钟教你终极算法—分代搜集算法） - 简书 (jianshu.com)</a>)</p><h2 id="9、JMM"><a href="#9、JMM" class="headerlink" title="9、JMM"></a>9、JMM</h2><p>==java memory model==</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul><li>java内存模型(Java Memory Model)</li><li>Java的并发采用的是共享内存模型</li><li>不存在的东西，虚无的概念，约定</li><li>JSR133中指定了JMM是用来定义一个一致的、跨平台的内存模型<ul><li>==是缓存一致性协议，用来定义数据读写的规则。==</li><li>JSR：JavaSpecification Requests java规范提案，是指向JCP(JavaCommunity Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。简单的就是jsr是java开发者以及授权者指定的标准，而java开发者以及授权者形成一个jcp国际组织。职能是指定java标准。</li><li>JCP由SUN于1995年创造Java的非正式过程，演进到如今有数百名来自世界各地Java代表成员一同监督Java发展的正式程序 。<ul><li>官方网站是：<a href="https://www.jcp.org/en/home/index">https://www.jcp.org/en/home/index</a></li><li>维护的范围：J2ME、J2SE、J2EE，XML，OSS，JAIN等规范</li></ul></li></ul></li></ul><h3 id="JMM同步约定"><a href="#JMM同步约定" class="headerlink" title="JMM同步约定"></a>JMM同步约定</h3><ol><li>线程解锁前，必须把共享变量立刻刷回主存</li><li>线程加锁前，必须读取主存中的最新值到工作内存中</li><li>解锁和加锁是同一把锁</li></ol><h3 id="JMM作用"><a href="#JMM作用" class="headerlink" title="JMM作用"></a>JMM作用</h3><ul><li><p>缓存⼀致性协议，⽤于定义数据读写的规则（遵守，找到这个规则）。</p></li><li><p>从抽象的⻆度来看，JMM定义了线程⼯作内存和主内存之间的抽象关系：线程之间的共享变量 存储在主内存（Main Memory)中，每个线程都有⼀个私有的本地内存（LocalMemory)。</p><p><img src="https://gitee.com/csdnm/pic-go/raw/master/img/image-20210516233353373.png" alt="image-20210516233353373"></p></li></ul><p>==解决共享对象可⻅性这个问题：==</p><p>[参考:](<a href="http://www.hellojava.com/a/77344.html">BAT经典面试题，深入理解Java内存模型JMM - HelloJava菜鸟社区</a>)</p><h3 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h3><p>JMM：抽象的概念，理论</p><h5 id="JMM对这八种指令的使用，制定了如下规则："><a href="#JMM对这八种指令的使用，制定了如下规则：" class="headerlink" title="JMM对这八种指令的使用，制定了如下规则："></a>JMM对这八种指令的使用，制定了如下规则：</h5><ol><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存 </li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量 实施use、store操作之前，必须经过assign和load操作 </li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 </li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 </li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ol><ul><li>JMM对这⼋种操作规则和对volatile的⼀些特殊规则就能==确定哪⾥操作是线程安全，哪些操作是线程 不安全的==了。</li><li>但是这些规则实在复杂，很难在实践中直接分析。所以⼀般我们也不会通过上述规则进⾏分 析。更多的时候，使⽤java的happen-before规则来进⾏分析。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/lizheng/2021/08/19/hello-world/"/>
    <url>/lizheng/2021/08/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
